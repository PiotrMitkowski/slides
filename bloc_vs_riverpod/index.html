<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css2?family=Montserrat&display=swap);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Montserrat', sans-serif; }

      h1, h2, h3 {color: #1A237E; }

      a {
        text-decoration: none;
      }

      li { line-height: 1.5em; }

      .inverse {
        background: #1A237E;
        color: white;
        text-shadow: 0 0 20px #777;
      }
      
      .inverse > h1 { color: white; }

      .remark-code, .remark-inline-code {
         font-family: 'Ubuntu Mono';
         font-size: 0.8em;
         line-height: 1.3em;
      }


      .left-column {
        float: left;
        width: 49%;
      }

      .right-column {
        float: right;
        width: 49%;
      }

      .bio-image > img {
        width: 75%;
        border-radius: 50%;
      }

      .center-image, .center-image > img {
        margin: 0 auto;
        height: 40vh;
        display: block;
      }

      .center-image-wide, .center-image-wide > img {
        margin: 0 auto;
        height: 20vh;
        display: block;
      }

      .paragraph {
        display:block;
      }

      .social-container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }

      .social-container-column {
        flex-grow: 1;
        text-align: center;
      }

      .social-link-tile {
        margin-bottom: 5em;
      }

      .social-link-tile a{
        font-size: 0.8em;
      }

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, inverse

# Riverpod for Bloc users 

???
- Om√≥wienie Riverpoda
- nie "przej≈õcie przez wszystkie ficzery", a spojrzenie z perspektywy Bloca
- jak mozemy go wykorzystac
- zadawanie pyta≈Ñ, najlepiej przez podniesienie "≈Çapki"

---

# Agenda


.left-column[
- Context
- Facts
- Bloc vs. Riverpod - overview
- Bloc vs. Riverpod - Flutter Template
- Tidbits!
]

???
1. T≈Ço, kontekst rozmowy o Riverpodzie i State Management og√≥lnie
2. Kilka suchych fakt√≥w z Bloca i Riverpoda, dla por√≥wnania
3. Spojrzenie na og√≥lne za≈Çozenia obu narzƒôdzi
4. Przyk≈Çad implementacji na podstawie Flutter Template
5. Smaczki z Riverpoda, kt√≥rych nie ma w Blocu

---
class: center, middle

## Context

---

## Context

The best state management solution in Flutter:

???
- zaglƒÖdanie na Twittera
- temat state management czƒôsto siƒô tam pojawia
- rozmowa o najlepszym/rekomendowanym narzƒôdziu State Management wyglƒÖda tak:

--

.center-image[![](assets/cats-fighting.gif)]

---

## Context

.center-image[![](assets/flutter_state_confusion.png)]

Source: [Codemagic blogpost by A. Salvadorini](https://blog.codemagic.io/flutter-state-management-part-1/)

???
- Walka toczy siƒô od 2018, kiedy wzorzec BLoC zosta≈Ç om√≥wiony na Google I/O (Filip Hracek, Matt Sullivan)
- Potem doszed≈Ç Provider, o kt√≥rym rok p√≥≈∫niej opowiada≈Ça ta sama dw√≥jka
- Wpad≈Ço jeszcze kilka innych rozwiƒÖza≈Ñ
- Flutter Team nie daje jednoznacznej rekomendacji - wielu zwolennik√≥w i przeciwnik√≥w takiego podej≈õcia
- Warto podej≈õc do state management, jak do kolejnego narzƒôdzia - m≈Çotek i gwo≈∫dzie
- warto wypracowac jeden,lub kilka wewnƒôtrznych standard√≥w i stosowac je w zaleznosci od projekt√≥w
---


## Standarized solution

.center-image[![](assets/standards_2x.png)]

???
- walka jednak trwa i community ca≈Çy czas dƒÖzy do wypracowania standard√≥w
- wiemy, jak to ze standaryzacjƒÖ bywa -> komiks
- Riverpod jest efektem dƒÖzenia do standardu i sta≈Çego ulepszania narzƒôdzi
w zakresie SM

---

class: center, middle

# Facts

.center-image[![](assets/bears-beats.gif)]

???
- Zanim przyjrzymy siƒô Riverpodowi blizej -> kilka suchych fakt√≥w

---

## Facts
.left-column[
### Bloc
  - created by F. Angelov / VGV
  - Oct 2018
  - BLoC pattern
  - 10.5k Github stars
  - 7.8k Pub likes (combined)
]
.right-column[
### Riverpod
  - created by R. Rousslet
  - Apr 2020
  - `provider` rewrite
  - 4.5k Github stars
  - 4.1k Pub likes (combined)
]

???
- Bloc istnieje od 2018, powsta≈Ç jako implementacja wzorca BLoC 
- Riverpod powsta≈Ç w 2020 roku jako rewrite providera
- autor√≥w obu narzƒôdzi raczej nie trzeba przedstawiac
- statystyki popularno≈õci z GH i Pub.dev przemawiajƒÖ za Bloc, co w g≈Ç√≥wnej mierze wynika
z czasu obecno≈õci na rynku - Bloc ma bardziej ugruntowanƒÖ pozycjƒô
- oba narzƒôdzia sƒÖ rozbite na kilka osobnych paczek: core, flutter, hooks, inne (dev tools) 

---

class: center, middle

# Overview

???
- Spojrzenie na za≈Çozenia obu narzƒôdzi

---

## Bloc

.center-image[![](assets/bloc_pattern_diagram.png)]

Source: [Flutteris blog](https://www.flutteris.com/blog/en/reactive-programming-streams-bloc)

???

- narzucony wzorzec Business Logic Components
- w centrum aplikacji mamy komponenty logiki biznesowej
- komponenty nas≈ÇuchujƒÖ zdarze≈Ñ, przetwarzajƒÖ otrzymane zdarzenia, a nastƒôpnie przekazujƒÖ wynik przetwarzania
do ich s≈Çuchaczy (Widgety)
- separation of concerns

---

## Bloc

.center-image-wide[![](assets/bloc_architecture_full.png)]

.center-image-wide[![](assets/cubit_architecture_full.png)]

Source: [Bloc docs](https://bloclibrary.dev/#/coreconcepts)

???

- g≈Ç√≥wnƒÖ jednostkƒÖ zarzƒÖdzania stanem jest Cubit (lub Bloc)
- ka≈ºdy Cubit ma przypisany konkretny stan (dla Bloca dochodzƒÖ jeszcze eventy)
- manipulacja stanem odbywa siƒô¬†przez wywo≈Çywanie metod Cubita (wysy≈Çanie event√≥w do Bloca)
- dwa podej≈õcia do budowy stanu: klasa per ka≈ºdy mo≈ºliwy stan lub jedna klasa stanu i pole `state`, bƒôdƒÖce enumem
- cubity sƒÖ osadzane w widget tree poprzez `BlocProvider`, a odczytywane poprzez BlocBuilder/Listener/Consumer/metody na BuildContext

---

## Riverpod

.center-image[![](assets/riverpod_various_archs.png)]

Source: [Code with Andrea](https://codewithandrea.com/articles/flutter-app-architecture-riverpod-introduction/)

???

- brak narzuconej architektury - mo≈ºemy to sobie dowolnie pouk≈Çadaƒá
- w centrum zarzƒÖdzania stanem sƒÖ Providery, kt√≥re odpowiadajƒÖ¬†za dostarczenie pewnych obiekt√≥w/warto≈õci do element√≥w widget tree
- Provider mo≈ºe dostarczaƒá praktycznie dowolny obiekt/primitive value (z ma≈Çymi ograniczeniami); mo≈ºe byƒá u≈ºywany jako samodzielne DI, bez konieczno≈õci dodawania GetIt
- rekomendowane podej≈õcie ‚Äúcubitowe‚Äù - klasa StateNotifier operujƒÖca na stanie; zmiana stanu odbywa siƒô¬†przez wywo≈Çywanie metod na klasie StateNotifier
- istotna informacja - providery sƒÖ niezale≈ºne od *widget tree*; ich kontener jest ca≈Çkowicie poza drzewem (a dok≈Çadniej na samym jego szczycie), a dostƒôp do jego sk≈Çadowych nie wymaga build contextu

---

## Riverpod

.center-image[![](assets/riverpod_providers_table.png)]

Source: [Riverpod docs](https://riverpod.dev/docs/concepts/providers#different-types-of-providers)

???
- o ile Bloc ma jeden uniwersalny Provider, o tyle w riverpodzie jest kilka r√≥znych typ√≥w
- nas najbardziej interesujƒÖ Provider i StateNotifierProvider

---

class: center, middle

# Bloc vs. Riverpod - Flutter template

.center-image[![](assets/talk_is_cheap.jpeg)]

???
- Wystarczy teorii, pora przej≈õc do kodu

---

## App startup - Bloc

```dart
void main() async {
  ...
  runApp(const TemplateApp());
}
```

???
- nic nadzwyczajnego

---

## App startup - Riverpod

```dart
void main() async {
  ...
*  runApp(ProviderScope(child: const TemplateApp()));
}
```

???
- Opakowanie appki przez `ProviderScope` - klasy odpowiedzialnej za zarzƒÖdzanie 
kontenerem Provider√≥w

---

## DI - Bloc
```dart
void _setupData() {
  serviceLocator
    ..registerSingleton<HiveInterface>(Hive)
    ..registerSingleton(Preferences(serviceLocator()))
    ..registerFactory(HeaderInterceptor.new)
    ..registerFactory(LoggerInterceptor.new)
    ..registerLazySingleton(
      () => DioHelper.createDioInstance(serviceLocator(), serviceLocator())
    )
*   ..registerFactory(() => TasksRestClient(serviceLocator()))
*   ..registerFactory(() => TasksRepository(serviceLocator()));
}

void _setupFirebase() {
  return serviceLocator
    ..registerLazySingleton(() => FirebaseAnalytics.instance)
    ..registerLazySingleton(
      () => FirebaseAnalyticsObserver(analytics: serviceLocator())
    );
}

*void _setupCubits() {
* serviceLocator.registerFactory(() => TasksCubit(serviceLocator()));
*}
```

???
- standardowe DI 
- wstrzykiwanie wszystkich element√≥w od najnizszych warstw (zewnƒôtrzne biblioteki, Rest client), przez repozytoria,
az po jednostki logiki biznesowej, czyli Cubity

---

## DI - Riverpod
```dart
void _setupData() {
  serviceLocator
    ..registerSingleton<HiveInterface>(Hive)
    ..registerSingleton(Preferences(serviceLocator()))
    ..registerFactory(HeaderInterceptor.new)
    ..registerFactory(LoggerInterceptor.new)
    ..registerLazySingleton(
      () => DioHelper.createDioInstance(serviceLocator(), serviceLocator())
    );
*
}

void _setupFirebase() {
  return serviceLocator
    ..registerLazySingleton(() => FirebaseAnalytics.instance)
    ..registerLazySingleton(
      () => FirebaseAnalyticsObserver(analytics: serviceLocator())
    );
}
*
```

???
- tak naprawdƒô¬†nie jest to potrzebne - mozna wszystko przerzucic na Riverpoda
- za≈Çozenie - 3rd party przez GetIt, 1st party przez Riverpoda (Providery dla 3rd party wymagajƒÖ wiƒôcej boilerplate'a)
- wypad≈Ç rest client i repository
- wypad≈Ç cubit

---

## DI - Riverpod

```dart
class TasksRestClient {
  ...
}

*final tasksRestClientProvider = Provider<TasksRestClient>((ref) {
* return TasksRestClient(serviceLocator());
*});
```

```dart
class TasksRepository {
  const TasksRepository(this._restClient);

  final TasksRestClient _restClient;
  ...
}

*final tasksRepositoryProvider = Provider<TasksRepository>((ref) {
* final restClient = ref.read(tasksRestClientProvider);
  return TasksRepository(restClient);
});
```

???
- Provider - wrzucenie instancji do kontenera 
- providery jako zmienne globalne
- standardowy Provider - dla singleton√≥w bez ≈õledzenia zmian
- ref.read - standardowe odczytanie providera
- ref - odno≈õnik do kontenera provider√≥w
- providery sƒÖ odczytywane poprzez te globalne zmienne, a nie typy (jak w przypadku GetIt)

---

## Business logic - Bloc

```dart
*class TasksCubit extends Cubit<TasksState> {
  TasksCubit(this._repository) : super(const ShowLoading());

  final TasksRepository _repository;

  Future<void> loadTasks() async {
*   emit(const ShowLoading());

    final result = await _repository.getTasks();
    result.map(
*     failure: (failure) => emit(ShowError(failure.error.toString())),
*     success: (success) => emit(ShowTasks(success.value)),
    );
  }
}
```

???
Najwazniejsze punkty:
- Cubit jako klasa bazowa
- ustawianie nowego stanu poprzez `emit()`

---

## Business logic - Riverpod

```dart
*class TasksNotifier extends StateNotifier<TasksState> {
  TasksNotifier(this._repository) : super(const ShowLoading()) {
*    loadTasks();
  }

  final TasksRepository _repository;

  Future<void> loadTasks() async {
*    state = const ShowLoading();
    final result = await _repository.getTasks();
    result.map(
*      failure: (failure) => state = ShowError(failure.error.toString()),
*      success: (success) => state = ShowTasks(success.value),
    );
  }
}

*final tasksNotifierProvider = StateNotifierProvider<TasksNotifier, TasksState>(
  (ref) {
    final tasksRepository = ref.read(tasksRepositoryProvider);
    return TasksNotifier(tasksRepository);
  },
);
```

???
- StateNotifier jako klasa bazowa
- Type parameter dla state'a
- przypisanie do `state` zamiast `emit()`
- uzycie odpowiedniego providera - StateNotifierProvider (inaczej listenery nie bƒôdƒÖ powiadamiane o zmianach)
  - bardzo prosty, czƒôsty b≈ÇƒÖd przy pracy z Riverpodem
- inicjalizacja w konstruktorze, nigdy w Widgecie (jak w przypadku bloca)
  - prowadzi do b≈Çƒôdu o pr√≥bie zbudowania Widgetu, kt√≥ry nie sko≈Ñczy≈Ç poprzedniego budowania
  - mozna to obejsc poprzez wywolanie `init` ref.listen, albo `postFrameCallback`,
ale jest to malo przyjemne

---

## Bloc - UI

```dart
*class TasksPage extends StatelessWidget {
  ...

  @override
* Widget build(BuildContext context) {
*   return BlocProvider(
*     create: (_) => serviceLocator.get<TasksCubit>()..loadTasks(),
      child: Scaffold(
*       body: BlocBuilder<TasksCubit, TasksState>(
*         builder: (context, state) {
            return state.map(
              ...
            );
          },
        ),
      ),
    );
  }
}
```

???
- wstrzykniƒôcie Cubita do widget tree - BlocProvider
- inicjalizacja w `create()`
- odczyt - BlocBuilder, builder callback z aktualnym stanem

---

## Riverpod - UI

```dart
*class TasksPage extends ConsumerWidget {
  ...

  @override
* Widget build(BuildContext context, WidgetRef ref) {
*   return Scaffold(
*     body: Consumer(
*       builder: (context, ref, child) {
*         final state = ref.watch(tasksNotifierProvider);
          return state.map(
            ...
          );
        },
      ),
    );
  }
}
```

???
- inna klasa bazowa Widgetu - ConsumerWidget
  - dostƒôpny r√≥wniez odpowiednik ze stanem - ConsumerStatefulWidget
- metoda `build()` z dodatkowym argumentem
- Consumer zamiast BlocBuildera
- tak naprawdƒô Consumer nie jest zawsze potrzebny i mo≈ºemy uzywac `ref` z metody build,
Consumera wprowadzamy w celu ograniczenia build scope

---

## Changes without rebuilds

### Bloc
```dart
BlocListener<TasksCubit, TasksState>(
* listener: (context, state) {
    // do stuff here based on TasksCubit's state
  },
),
```

### Riverpod
```dart
  Widget build(BuildContext context, WidgetRef ref) {
*   ref.listen(tasksNotifierProvider, (previousState, nextState) {
      // do stuff here based on TasksNotifier's state
    });
    
    return Container();
  }
```

???
- reagowanie na zmiany stanu bez przebudowy widzet√≥w
- analogiczne konstrukcje, w Riverpodzie mamy jeszcze dostƒôp do poprzedniego stanu
- kto≈õ, kto uzywal providera ten wie, jak ciƒôzkie jest zrobienie takiego listenera

---

## Testing - business logic unit

```dart
test('should emit ShowLoading as default state', () {
  when(() => mockTasksRepository.getTasks())
    .thenAnswer((_) => Future.value(Result.success(const [])));

  testedNotifier = TasksNotifier(mockTasksRepository);

* expect(testedNotifier.debugState, isA<ShowLoading>());
});

test('should emit ShowTasks after successful load', () async {
  when(() => mockTasksRepository.getTasks())
    .thenAnswer((_) => Future.value(Result.success(const [])));

  testedNotifier = TasksNotifier(mockTasksRepository);

  await expectLater(
*   testedNotifier.stream,
    emitsInOrder([
      const ShowTasks([]),
    ]),
  );
});
```

???
- nie ma za bardzo r√≥znicy miedzy Bloc'iem i Riverpodem
- nie mamy oczywiscie odpowiednika `bloc_test` :D
- jedyna roznica wynika z tego, ze Riverpod odpala metodƒô `init` w konstruktorze,
wiec testowanie tego jest troche toporne
- `debugState` zamiast `state` - ten drugi jest oznaczony jako `protected`

---

## Widget Testing - Bloc

```dart
setUpAll(() async {
  await setupTestServiceLocator();
* serviceLocator
*   ..unregister<TasksCubit>()
*   ..registerSingleton<TasksCubit>(TasksCubitMock());
  mockNavigator = MockNavigator();
});

setUp(() {
  testedWidget = TemplateApp(
    testWidget: MockNavigatorProvider(
      navigator: mockNavigator,
      child: const TasksPage(
        TasksPageArguments(title: 'Mocked Tasks'),
      ),
    ),
  );
});
```

???
- r√≥wniez nie ma za bardzo r√≥znic, poza DI
- Bloc - nadpisanie zaleznosci w GetIt

---

## Widget Testing - Riverpod

```dart
setUpAll(() async {
  await setupTestServiceLocator();
*  
  mockNavigator = MockNavigator();
});

setUp(() {
  mockTasksRepository = MockTasksRepository();
* testedWidget = ProviderScope(
*   overrides: [
*     tasksRepositoryProvider.overrideWith((ref) => mockTasksRepository),
*   ],
    child: TemplateApp(
      testWidget: MockNavigatorProvider(
        navigator: mockNavigator,
        child: const TasksPage(
          TasksPageArguments(title: 'Mocked Tasks'),
        ),
      ),
    ),
  );
});
```

???
- Riverpod - nadpisanie zaleznosci w ProviderScope
- pole `overrides`, kt√≥re przyjmuje tablicƒô z nadpisanymi providerami
- nadpisanie odbywa siƒô poprzez metodƒô `overrideWith`

---

class: center, middle

# Tidbits time!

???
- Tak wyglƒÖda zestawienie Bloca i Riverpoda. A co Riverpod oferuje opr√≥cz tego?

---

## `AsyncValue`

```dart
*class TasksNotifier extends StateNotifier<AsyncValue<TasksState>> {
* TasksNotifier(this._repository) : super(AsyncLoading()) {
    loadTasks();
  }

  final TasksRepository _repository;

  Future<void> loadTasks() async {
*   state = const AsyncLoading();
*   state = await AsyncValue.guard(() async {
      final tasks = await _repository.getTasks();
      return TasksState(tasks);
    });
  }
}
```

???
- obs≈Çuga operacji async w BLoCu -> 3 stany (loading, success, error)
- AsyncValue jest specjalnƒÖ¬†klasƒÖ, kt√≥ra obs≈Çuguje te 3 stany; mozna jej uzyc zamiast rƒôcznej implementacji 3 stan√≥w
- `AsyncValue` k≈Ç√≥ci siƒô ze zwracaniem `Result`, ale `Result` nie jest wtedy potrzebne
- od strony logiki biznesowej - operowanie na AsyncLoading, AsyncSuccess i AsyncError
- dodatkowo `AsyncValue.guard` - zastƒôpuje try/catch z przypisaniem Success po udanej operacji async
i przypisaniem Error wewnƒÖtrz `catch`

---

## `AsyncValue`

```dart
  body: Consumer(
    builder: (context, ref, child) {
      final state = ref.watch(tasksNotifierProvider);
      return state.map(
*       loading: (_) => const Center(
          child: CircularProgressIndicator(),
        ),
*       error: (state) {
          return ErrorWithRetry(
*           message: state.error.toString(),
            onRetry: () => context.read<TasksNotifier>().loadTasks(),
          );
        },
*       data: (state) => ListView.builder(
*         itemCount: state.value.tasks.length,
          itemBuilder: (context, index) => TaskItem(state.tasks[index]),
        ),
      );
    },
  ),
```

???
- po stronie UI - gotowa metoda `map`, obs≈ÇugujƒÖca te 3 stany

---

## Modifiers
### autoDispose
```dart
*final tasksNotifierProvider = StateNotifierProvider.autoDispose<TasksNotifier, TasksState>((ref) {
  final tasksRepository = ref.watch(tasksRepositoryProvider);
  return TasksNotifier(tasksRepository);
});
```

???
- kolejny unikalny element - modyfikatory
- pierwszy z nich to `autoDispose`
- obs≈Çuga sytuacji, gdy chcemy usunƒÖc providera, gdy nie jest aktywnie uzywany
  - zamkniƒôcie po≈ÇƒÖczenia z Firebase, zeby nie ponosic koszt√≥w
  - zresetowanie stanu, gdy user zamknie dany ekran

---

## Modifiers
### family
```dart
*final taskDetailsNotifierProvider = StateNotifierProvider.family
*       <TaskDetailsNotifier, TaskDetailsState, int>((ref, taskId) {
  final tasksRepository = ref.watch(tasksRepositoryProvider);
  return TaskDetailsNotifier(taskId);
});

// then
Widget build(BuildContext context, WidgetRef ref) {
* final state = ref.watch(taskDetailsNotifierProvider(taskId));
}
```
???
- kolejny modyfikator - family
- parametryzacja Providerow - na przyk≈Çad, gdy mamy dedykowany provider dla ekranu szczeg√≥≈Ç√≥w taska
- mozemy wtedy przekazac id taska do utworzenia instancji providera
- po stronie UI traktujemy provider jako metodƒô, do kt√≥rej przekazujemy nasz parametr - taskId 

---
## Modifiers

### combining modifiers
```dart
*final taskDetailsNotifierProvider = StateNotifierProvider.autoDispose.family
        <TaskDetailsNotifier, TaskDetailsState, int>((ref, taskId) {
  ...
});
```

???
- modyfikatory mozna ≈ÇƒÖczyc

---

## Provider for everything


```dart
class TasksRepository {
  List<Task> getTasks();

  Stream<List<Task>> watchTasks();

  Stream<Task?> watchTask(int id);
}

final tasksRepositoryProvider = Provider<TasksRepository>(
  (ref) => TasksRepository(),
);

*final tasksStreamProvider = StreamProvider.autoDispose<List<Task>>((ref) {
  final tasksRepository = ref.watch(tasksRepositoryProvider);
  return tasksRepository.watchTasks();
});

*final taskProvider = StreamProvider.autoDispose.family<Task?, int>((ref, taskId) {
  final tasksRepository = ref.watch(tasksRepositoryProvider);
  return tasksRepository.watchTask(taskId);
});
```

???
- czƒôstƒÖ praktykƒÖ, jest tworzenie Provider√≥w dla stream√≥w i Future's
- praca tylko z API Riverpoda, bez Stream/Future API (bardziej wygodne)
- Riverpod zajmuje siƒô cyklem zycia providera (autoDispose) - brak koniecznosci rƒôcznego zamykania stream√≥w

---
class: middle, center
### üî•üî•üî• ###

### `Future<T> + FutureProvider = AsyncValue<T>`

### `Stream<T> + StreamProvider = AsyncValue<T>`

???
- Opakowanie Future/Stream w odpowiedniego Providera -> operowanie na AsyncValue
- Przy prostych ekranach to w zasadzie eliminuje potrzebƒô korzystania ze StateNotifiera

---

## `riverpod_generator`

#### Converts this:
```dart
class TasksRepository {
  ....
}

*final tasksRepositoryProvider = Provider<TasksRepository>((ref) {
*  ...
*});
```
#### Into this:
```dart
*@riverpod
class TasksRepository {
  ....
}
*
```

???
- Riverpod dostarcza kilka roznych providerow
- Czasami ciezko jest stwierdzic, ktory provider pasuje do danego przypadku
- Do tego mamy duzo boilerplate'a - minimum 3 linijki na kazdƒÖ rzecz, kt√≥rƒÖ chcemy
wrzucic do kontenera z providerami
- `riverpod_generator` rozwiƒÖzuje te kwestie
- samodzielne dopasowanie typu Providera + adnotacja zamiast boilerplate

---
class: center, middle
![](assets/wait_what.webp)

???
- code generation do narzƒôdzia do zarzƒÖdzania stanem ü´£
- rzecz, kt√≥ra budzi najwiƒôksze wƒÖtpliwo≈õci
- je≈õli praca z SM wymaga generowania kodu, to co≈õ jest nie tak
- Remy jest ≈õwiadomy problemu -> metaprogramming

---

## Final remarks

.left-column[
### High flexibility
- Any architecture
- DI
- Easy overrides
]  

.right-column[
### Average maturity
- Not many good examples
- Missing docs
- Code generation...
]  

???
- dwie g≈Ç√≥wne cechy
  - wysoka elastyczno≈õc - implementacja dowolnej architektury, wbudowane DI, kt√≥re ≈Çatwo siƒô nadpisuje
  - umiarkowana dojrza≈Ço≈õc - trochƒô brakuje dobrych przyk≈Çad√≥w; docsy dla V2 sƒÖ WIP;
- code generation - bardziej dojrza≈Çe narzƒôdzie by≈Çoby prostsze
- dobry case `pisania od zera` - rozwiƒÖzujemy znane problemy, ale wprowadzamy nowe
- mimo wszystko - warte zachodu!

---

## Final remarks

.left-column[
### Good at:
- Startups
- POCs
- R&D
]

.right-column[
### Not as good at:
- Stable projects
- Enterprises
]

???
- rekomendacja projektowa
  - dynamiczne projekty, o duzej zmienno≈õci
  - startupy/POCs/inne projekty z dziedziny R&D
  - w bardziej stabilnych ≈õrodowiskach moze nie byc az tak wygodny, jak Bloc (ale to tylko teoretyczna obserwacja)

---

class: center, middle

# Q&A

???
- to wszystko na dzi≈õ, zapraszam do zadawania pyta≈Ñ

---

# See you around!

.social-container[
  .social-container-column[
  .social-link-tile[
  #### Twitter
  [@piotrmitkowski](https://twitter.com/piotrmitkowski)
  ]
  .social-link-tile[
  #### Github
  [/PiotrMitkowski](https://github.com/PiotrMitkowski)
  ]
  ]
  .social-container-column[
  .social-link-tile[
  #### LinkedIn
  [in/piotr-mitkowski](https:/linkedin.com/in/piotr-mitkowski)
  ]
  .social-link-tile[
  #### WWW
  [mitkowski.dev](https://mitkowski.dev)
  ]
  ]
]


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLines: true,
      });
    </script>
  </body>
</html>